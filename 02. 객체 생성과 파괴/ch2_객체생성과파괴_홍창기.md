# 이펙티브 자바 2장 : 객체 생성과 파괴

> 출처 : 이펙티브 자바, 3rd Edition
> 2024.06.12. 수 작성

## ✅ 아이템 1 : 생성자 대신 "정적 팩토리 메서드"를 고려하라.

- 정적 팩토리 메서드(static factory method) : 그 클래스의 인스턴스를 반환하는 단순한 정적 메서드
- 클래스는 클라이언트에 public 생성자 대신, 혹은 생성자와 함께 정적 팩토리 메서드를 제공할 수 있다.
- 정적 팩토리 메서드가 생성자보다 좋은 장점으로 아래의 5가지가 있다.

### 장점 1 : 이름을 가질 수 있다.

- 생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지 못한다.
- 반면, static 팩토리 메서드는 **이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사**할 수 있다.
- 한 클래스에 시그니처가 같은 생성자가 여러 개 필요할 경우, 생성자를 static 팩토리 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름을 지어주는 것이 좋다.

### 장점 2 : 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.

- 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 방식으로 **불필요한 객체 생성을 막을 수 있다.** → 불변 클래스(immutable class, 아이템 17)
    - ex) `Boolean.valueOf(boolean)` 메서드는 객체를 아예 생성하지 않는다.
- 따라서 (특히 생성 비용이 큰) 같은 객체가 자주 요청되는 상황이라면, 성능을 상당히 끌어올릴 수 있다.
- 반복되는 요청에 같은 객체를 반환하는 방식으로 정적 팩토리 방식의 클래스에서 언제 어느 인스턴스를 살아있게 할지를 철저하게 통제할 수 있다.
- 인스턴스를 왜 통제해야 하는가?
    - 인스턴스를 통제하면 클래스를 싱글톤(singleton, 아이템 3) 또는 인스턴스화 불가(noninstantiable, 아이템 4)로 만들 수도 있다.
    - 또한 불변 값 클래스(아이템 17)에서 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다.
    - 인스턴스 통제는 플라이웨이트 패턴의 근간이 된다.
    - 열거 타입(아이템 34)은 인스턴스가 하나만 만들어지는 것을 보장한다.

### 장점 3 : 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

- 덕분에 **반환할 객체의 클래스를 자유롭게 선택할 수 있는 엄청난 유연성**을 가질 수 있다.
    - 이는 인터페이스를 static 팩토리 메서드의 반환 타입으로 사용하는 인터페이스 기반 프레임워크(아이템 20)를 만드는 핵심 기술이다.
- 따라서 API를 만들 때 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어서 **API를 작게 유지할 수 있다.**
    - 프로그래머가 API를 사용하기 위해 **익혀야 하는 개념의 수와 난이도를 낮출 수 있다.** 프로그래머 입장에서 명시한 인터페이스대로 동작하는 객체를 이 API를 통해 얻을 수 있으므로, 굳이 문서를 찾아가며 **실제 구현 클래스가 무엇인지 알아보지 않아도 된다.**
    - 자바 8 이전에는 인터페이스에서 static 메서드를 선언할 수 없었다. 따라서 이름이 Type인 인터페이스를 반환하는 static 메서드가 필요할 경우, 인스턴스화 불가인 동반 클래스 Types를 만들고 그 안에서 static 메서드를 정의하는 것이 관례였다.
        - ex) Collection과 Collections의 관계
- static 팩토리 메서드를 사용하는 클라이언트는 **얻은 객체를 구현 클래스가 아닌 인터페이스로 다루게 되는데**(아이템 64), 이것은 일반적으로 좋은 습관이다.

### 장점 4 : 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

- 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.
- 심지어 다음 릴리스에서는 또 다른 클래스의 객체를 반환해도 된다. 하위 클래스를 사용할 이점이 없어진다면 다음 릴리스 때는 이를 삭제해도 아무 문제가 없다. 또한 성능을 개선한 다른 하위 클래스를 다음 릴리스에서 추가할 수도 있다.
- 즉, 클라이언트는 팩토리가 건네주는 객체가 어느 클래스의 인스턴스인지 알 수 없고 알 필요도 없다. 그저 반환 타입의 하위 클래스이기만 하면 되는 것이다.

### 장점 5 : static 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

- 이런 유연함은 서비스 제공자 프레임워크(service provider framework)를 만드는 근간이 된다.
    - 대표적인 서비스 제공자 프레임워크 : JDBC(Java Database Connectivity)
    - 서비스 제공자 프레임워크에서 제공자(provider)는 서비스의 구현체다. 그리고 이 구현체들을 클라이언트에 제공하는 역할을 프레임워크가 통제한다. 따라서 클라이언트를 구현체로부터 분리해준다.
- 서비스 제공자 프레임워크를 이루는 3개의 핵심 컴포넌트
    - 서비스 인터페이스 (service interface) : 구현체의 동작을 정의한다. ex) JDBC의 `Connection`
    - 제공자 등록 API (provider registration API) : 제공자가 구현체를 등록할 때 사용한다. ex) JDBC의 `DriverManager.registerDriver`
    - 서비스 접근 API (service access API) : 클라이언트가 서비스의 인스턴스를 얻을 때 사용한다. ex) JDBC의 `DriverManager.getConnection`
    - 클라이언트는 서비스 접근 API를 사용할 때 원하는 구현체의 조건을 명시할 수 있다. 조건을 명시하지 않으면 기본 구현체를 반환하거나 지원하는 구현체들을 하나씩 돌아가며 반환한다. 이 서비스 접근 API가 바로 서비스 제공자 프레임워크의 근간이라고 한 유연한 static 팩토리의 실체다.
- 3개의 핵심 컴포넌트 외에도 서비스 제공자 인터페이스라는 4번째 컴포넌트가 종종 사용되기도 한다.
    - 서비스 제공자 인터페이스(service provider interface) : 서비스 인터페이스의 인스턴스를 생성하는 팩토리 객체를 설명한다. ex) JDBC의 `Driver`

### 단점 1 : 상속을 하려면 public이나 protected 생성자가 필요하므로, static 팩토리 메서드만 제공하면 하위 메서드를 만들 수 없다.

- 다르게 생각하면, 이 제약은 상속보다 컴포지션(아이템 18)을 사용하도록 유도한다는 점, 그리고 불변 타입으로 만들기 위해서는 이 제약을 지켜야 한다는 점에서 **오히려 장점으로 받아들일 수도 있다.**

### 단점 2 : static 팩토리 메서드는 프로그래머가 찾기 어렵다.

- 생성자는 API 설명에서 명확하게 드러나지만, static 팩토리 메서드는 그렇지 않다.
- **따라서 API 문서를 잘 써놓아야 하고, 널리 알려진 규약을 따라 메서드 이름을 잘 지어야 한다.**
    - `from` : 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
    - `of` : 여러 매개변수를 받아서 적합한 타입의 인스턴스를 반환하는 집계 메서드
    - `valueOf` : from과 of의 더 자세한 버전
    - `instance` 또는 `getInstance` : (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.
    - `create` 또는 `newInstance` : `instance` 또는 `getInstance` 와 같지만, 매번 새로운 인스턴스를 생성하여 반환함을 보장한다.
    - `getType` : `getInstance` 와 같지만, 생성할 클래스가 아닌 다른 클래스에 팩토리 메서드를 정의할 때 사용한다. 여기서 `Type` 부분에 팩토리 메서드가 반환할 객체의 타입의 이름을 넣는다.
    - `newType` : `newInstance` 와 같지만, 생성할 클래스가 아닌 다른 클래스에 팩토리 메서드를 정의할 때 사용한다. 여기서 `Type` 부분에 팩토리 메서드가 반환할 객체의 타입의 이름을 넣는다.
    - `type` : `getType` 과 `newType` 의 간결한 버전이다.

## ✅ 아이템 2 : 생성자에 매개변수가 많다면, "빌더"를 고려하라.

- static 팩토리와 생성자는 공통적으로 선택적 매개변수가 많은 경우에 적절하게 대응하기 어렵다는 한계가 있다.
- **선택적 매개변수가 많은데 static 팩토리와 생성자를 사용하는 경우**, 아래의 대안들을 고려할 수 있다.

### 대안 1 : 점층적 생성자 패턴 (telescoping constructor pattern)

- 점층적 생성자 패턴 : 필수 매개변수만 받는 생성자, 필수 매개변수와 선택 매개변수 1개를 받는 생성자, 필수 매개변수와 선택 매개변수 2개를 받는 생성자, …, 필수 매개변수와 선택 매개변수 모두를 받는 **생성자까지 모두 구현**하고, 생성 클래스의 인스턴스를 만들려면 **원하는 매개변수를 모두 포함한 생성자 중 가장 짧은 것을 호출**하는 방식이다.
- 점층적 생성자 패턴의 단점 : **사용자가 설정하고 싶지 않은 매개변수까지 값을 어쩔 수 없이 지정해줘야 하는 경우가 많아진다.** 따라서 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어려워진다.

### 대안 2 : 자바빈즈 패턴 (JavaBeans Pattern)

- 자바빈즈 패턴 : **매개변수가 없는 생성자로 객체를 만든 후, setter 메서드들을 호출**하여 원하는 매개변수의 값을 설정하는 방식이다.
- 자바빈즈 패턴에서 점층적 생성자 패턴의 단점은 보이지 않는다. 코드가 길어지긴 했지만 **인스턴스를 만들기 쉬우므로 코드를 읽기 쉬워진다.**
- 자바빈즈 패턴의 심각한 단점 : **객체 하나를 만들려면 메서드를 여러 개 호출해야 하고, 객체가 완전하게 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.**
    - 일관성이 깨진 객체가 만들어지면, 버그를 심은 코드와 그 버그 때문에 런타임에 문제를 겪는 코드가 물리적으로 떨어져 있게 되므로 디버깅이 힘들어진다.
    - 점층적 생성자 패턴에서는 매개변수들이 유효한지를 생성자에서만 확인하면 일관성을 유지할 수 있었는데, 자바빈즈 패턴에서는 그러한 장치가 완전히 사라졌다.
    - 일관성이 무너지는 문제로 인해 자바빈즈 패턴에서는 클래스를 불변(아이템 17)으로 만들 수 없으며, 스레드 안전성을 얻으려면 프로그래머가 추가 작업을 해줘야 한다.

### 대안 3 : 빌더 패턴 (Builder Pattern)

- 점층적 생성자 패턴의 장점인 **안전성**과 자바빈즈 패턴의 장점인 **가독성**을 모두 가지고 있다.
- 빌더 패턴
    - 클라이언트가 필요한 객체를 직접 만드는 대신, **필수 매개변수만으로 생성자 또는 static 팩토리를 호출**해서 빌더 객체를 얻는다.
    - 이후 빌더 객체가 제공하는 **setter 메서드로 원하는 선택 매개변수들을 설정**한다.
    - 모든 매개변수를 설정했다면 마지막으로 **매개변수가 없는 `build` 메서드를 호출**해서 우리에게 필요한 객체를 얻는다.
- 빌더는 보통 **생성할 클래스 안에 static 멤버 클래스**로 만든다.
- **플루언트 API (fluent API) 또는 메서드 연쇄 (method chaining)** : 빌더의 setter 메서드들이 빌더 자신을 반환하게 해서 연쇄적으로 호출할 수 있도록 할 수 있다.
- 유효성 검사
    - 빌더의 생성자와 메서드에서 입력 매개변수를 검사하고, `build` 메서드가 호출하는 생성자에서 여러 매개변수에 걸친 불변식(invariant)을 검사한다.
    - 이런 불변식을 보장하고 공격에 대비하려면 빌더로부터 매개변수를 복사한 후 해당 객체 필드들도 검사해야 한다(아이템 50).
    - 검사 과정에서 잘못된 점을 발견하면 어떤 매개변수가 잘못되었는지를 자세히 알려주는 메시지를 담아 `IllegalArgumentException` 을 던진다(아이템 75).

> **불변(immutable 또는 immutability)은 어떠한 변경도 허용하지 않는다**는 의미이다. 주로 변경을 허용하는 가변(mutable) 객체와 구분하는 용도로 사용된다. 대표적으로 String 객체는 한번 만들어지면 절대 값을 바꿀 수 없는 불변 객체이다.
> **불변식(invariant)**은 프로그램이 실행되는 동안, 또는 정해진 기간동안 반드시 만족해야 하는 조건을 의미한다. 즉, **변경을 허용할 수는 있으나 주어진 조건 내에서만 허용한다**는 의미이다.
> 따라서 가변 객체에도 불변식이 존재할 수 있으며, 넓게 보면 불변은 불변식의 극단적인 예시라고 할 수 있다.

- **빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기 좋다.**
    - 각 계층의 클래스에 관련 빌더를 멤버로 정의한다. 추상 클래스는 추상 빌더를, 구체 클래스는 구체 빌더를 가지도록 한다.
- 빌더 패턴의 단점
    - 객체를 만들 때 우선 빌더부터 만들어야 한다. 빌더 생성 비용이 크지는 않지만, 성능이 민감한 상황에서는 문제가 될 수 있다.
    - 점층적 생성자 패턴보다는 코드가 장황해서 매개변수가 4개 이상은 되어야 값어치를 한다.
        - 다만 API는 시간이 지날수록 매개변수가 많아지는 경향이 있으므로, 빌더로 시작하는 편이 나을 때가 많다.

## ✅ 아이템 3 : private 생성자나 열거 타입으로 싱글톤을 보증하라.

- 싱글톤(singleton) : 인스턴스를 오직 하나만 생성할 수 있는 클래스
- 싱글톤의 단점
    - 클래스를 싱글톤으로 만들면 이 클래스를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.
- 싱글톤을 만드는 방식은 보통 아래의 방식1과 방식2가 있다.
    - 두 방식 모두 생성자를 private으로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련한다.

### 방식 1 : public 필드 방식

- private 생성자는 public static final 필드인 `Infikei.INSTANCE` 를 초기화할 때 딱 한 번만 호출된다.
- public이나 protected 생성자가 없으므로 클래스가 초기화될 때 만들어진 인스턴스가 전체 시스템에서 하나뿐임이 보장된다.
- 단 한 가지의 예외 : 권한이 있는 클라이언트는 리플렉션 API(아이템 65)인 `AccessibleObject.setAccessible` 을 사용하여 private 생성자를 호출할 수 있다.
    - 이러한 공격을 방어하려면 생성자를 수정하여 두 번째 객체가 생성되려고 할 때 예외를 던지게 하면 된다.
- 장점
    - 해당 클래스가 싱글톤이라는 것이 API에서 명백하게 드러난다.
    - 간결하다.

```java
public class Infikei {
    public static final Infikei INSTANCE = new Infikei();
    private Infikei() { ... }
    
    public void studyEffectiveJava() { ... }
}
```

### 방식 2 : static 팩토리 메서드를 public static 멤버로 제공한다.

- `Infikei.INSTANCE` 는 항상 같은 객체의 참조를 반환하므로 제2의 Infikei 인스턴스는 만들어지지 않는다.
- 단 한 가지의 예외 : 권한이 있는 클라이언트는 리플렉션 API(아이템 65)인 `AccessibleObject.setAccessible` 을 사용하여 private 생성자를 호출할 수 있다.
    - 이러한 공격을 방어하려면 생성자를 수정하여 두 번째 객체가 생성되려고 할 때 예외를 던지게 하면 된다.
- 장점
    - 마음이 바뀌어서 싱글톤이 아니게 변경하려고 할 때 API를 바꾸지 않아도 된다. 유일한 인스턴스를 반환하던 팩토리 메서드가 호출하는 스레드별로 다른 인스턴스를 넘겨주도록 할 수 있다.
    - 원한다면 static 팩토리를 generic 싱글톤 팩토리로 만들 수 있다(아이템 30).
    - static 팩토리의 메서드 참조를 공급자(supplier)로 사용할 수 있다(아이템 43, 44).
- 이러한 장점들이 굳이 필요하지 않다면 public 필드 방식이 좋다.

```java
public class Infikei {
    private static final Infikei INSTANCE = new Infikei();
    private Infikei() { ... }
    public static Infikei getInstance() { return INSTANCE; }
    
    public void studyEffectiveJava() { ... }
}
```

### 문제

- 둘 중 하나의 방식으로 만든 싱글톤 클래스를 직렬화하기 위해서는(12장 참조), 단순히 `Serializable` 을 구현하도록 선언하는 것만으로 부족하다.
- 모든 인스턴스 필드를 일시적(transient)이라고 선언하고, `readResolve` 메서드를 추가로 제공해야 한다(아이템 89).
    - 이렇게 하지 않으면 직렬화된 인스턴스를 역직렬화할 때마다 새로운 인스턴스가 만들어진다. 즉, 가짜 Infikei가 만들어지는 것이다.

```java
// 싱글톤임을 보장해주는 readResolve 메서드
private Object readResolve() {
    // 진짜 Infikei를 반환하고, 가짜 Infikei는 가비지 컬렉터에 맡긴다.
    return INSTANCE;
}
```

### 방식 3 : 원소가 하나인 열거 타입을 선언한다.

- public 필드 방식과 비슷하지만, 더 간결하고 추가 노력 없이 직렬화할 수 있다.
- 심지어 아주 복잡한 직렬화 상황이나 리플렉션 공격에서도 제2의 인스턴스가 생기는 일을 완벽히 막아준다.
- 조금 부자연스러워 보일 수는 있지만, **대부분의 상황에서는 이 방식이 싱글톤을 만드는 가장 좋은 방식**이다.
- 단, 만들려는 싱글톤이 Enum 외의 다른 클래스를 상속해야 하는 경우라면, 이 방법은 사용할 수 없다.
    - 열거 타입이 다른 인터페이스를 구현하도록 선언할 수는 있다.

```java
public enum Infikei {
    INSTANCE;
    
    public void studyEffectiveJava() { ... }
}
```

## ✅ 아이템 4 : 인스턴스화를 막으려면 private 생성자를 사용하라.

- 때때로 static 메서드와 static 필드만을 담은 클래스를 만들어야 하는 경우가 있다.
    - `java.lang.Math` 와 `java.util.Arrays` 처럼 기본 타입 값이나 배열 관련 메서드들을 모아놓은 클래스
    - `java.util.Collections` 처럼 특정 인터페이스를 구현하는 객체를 생성하는 static 메서드 또는 팩토리를 모아놓은 클래스
    - final 클래스와 관련한 메서드를 모아놓은 클래스 (final 클래스에서는 이 클래스를 상속해서 하위 클래스에 메서드를 넣는 것이 불가능하기 때문)
- static 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어서 사용하라고 설계한 것이 아니다.
- 생성자를 따로 명시하지 않으면 컴파일러가 자동으로 매개변수를 받지 않고 public인 기본 생성자를 만들어주며, 이 때문에 의도치 않게 인스턴스화할 수 있는 클래스가 만들어지게 된다.
- 또한 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다. 하위 클래스를 만들어서 인스턴스화할 수 있기 때문이다.
- 따라서 **클래스의 인스턴스화를 막기 위해서는 private 생성자를 추가해야 한다.**
- 이 방식은 상속을 불가능하게 하는 효과도 있다. 모든 생성자는 명시적이든 묵시적이든 상위 클래스의 생성자를 호출하는데, 생성자를 private으로 선언하면 하위 클래스가 상위 클래스의 생성자에 접근할 수 없게 되기 때문이다.

## ✅ 아이템 5 : 자원을 직접 명시하지 말고 "의존 객체 주입"을 사용하라.

- **사용하는 자원에 따라 동작이 달라지는 클래스에서는 static 유틸리티 클래스나 싱글톤 방식이 적합하지 않다.**
- 대신 클래스가 여러 자원 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원을 사용하도록 해야 한다.

### 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식

- 위의 조건을 만족하는 간단한 패턴이다.
- 이는 의존 객체 주입의 한 형태로, 맞춤법 검사기라는 객체를 생성할 때 의존 객체인 사전을 주입하는 것이다.
- **의존 객체 주입 형태는 아주 단순하다.** 수많은 프로그래머가 이 방식에 이름이 있다는 것도 모른 채 사용해왔을 정도이다.
- 예제에서는 딱 하나의 자원만 사용하지만, **자원이 몇 개든 의존 관계가 어떻든 상관없이 잘 작동한다.**
- 또한 **불변(아이템 17)을 보장**하여 (같은 자원을 사용하려는) 여러 클라이언트가 의존 객체들을 안심하고 공유할 수 있다.
- 의존 객체 주입은 생성자, static 팩토리(아이템 1), 빌더(아이템 2) 모두에 똑같이 응용할 수 있다.

### 변형 : 생성자에 자원 팩토리를 넘겨주는 방식

> 팩토리 : 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체

- 즉, 팩토리 메서드 패턴을 구현한 것이다.

### 의존 객체 주입의 장단점

- 유연성과 테스트 용이성을 개선해준다. 하지만 의존성이 수천 개나 되는 큰 프로젝트에서는 코드를 어지럽게 만들기도 한다. → 대거(Dagger), 주스(Guice), 스프링(Spring) 같은 의존 객체 주입 프레임워크를 사용하여 해소할 수 있다.

## ✅ 아이템 6 : 불필요한 객체 생성을 피하라.

- 똑같은 기능의 객체를 매번 생성하기보다 객체 하나를 재사용하는 것이 더 나을 때가 많다.
- **불변 클래스에서 생성자 대신 static 팩토리 메서드(아이템 1)를 제공하여 불필요한 객체 생성을 방지할 수 있다.**
    - 예를 들어, `Boolean(String)` 생성자 대신 `Boolean.valueOf(String)` 팩토리 메서드를 사용하는 것이 좋다. (그래서 이 생성자는 자바 9에서 사용 자제(deprecated) API로 지정되었다)
    - 생성자는 호출할 때마다 새로운 객체를 만들지만, 팩토리 메서드는 전혀 그렇지 않다.
    - 불변 객체만이 아니라 가변 객체여도 사용 중에 변경되지 않을 것임을 안다면 재사용할 수 있다.
- **생성 비용이 아주 비싼 객체가 반복해서 필요한 경우, 캐싱하여 재사용하는 것을 권장한다.**
    - 예를 들어 `String.matches` 메서드는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해서 사용하기는 적합하지 않다.
    - `String.matches` 메서드는 내부적으로 정규표현식용 `Pattern` 인스턴스를 만든다. `Pattern` 인스턴스는 입력받은 정규표현식에 해당하는 유한 상태 머신(finite state machine)을 만들기 때문에 인스턴스 생성 비용이 높다. 이 인스턴스가 한 번 쓰고 버려져서 곧바로 가비지 컬렉션 대상이 되기 때문에 성능적인 면에서 문제가 될 수 있다.
- 불필요한 객체를 만들어내는 또 다른 예시로 오토박싱(auto boxing)이 있다.

> 오토박싱(auto boxing) : 기본 타입과 박싱된 기본 타입을 섞어서 사용할 때 자동으로 상호 변환해주는 기술

- 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다. 의미상으로는 다를 것이 없지만, 성능에서는 그렇지 않기 때문이다(아이템 61).
- **따라서 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의해야 한다.**
- 이 내용을 **"객체 생성은 비싸므로 피해야 한다"로 오해하지 않아야 한다.** 특히 요즘의 JVM에서는 별다른 일을 하지 않는 작은 객체를 생성하고 회수하는 일이 크게 부담되지 않는다. 프로그램의 명확성, 간결성, 기능을 위해 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일이다.
- 거꾸로, **아주 무거운 객체가 아닌 이상 단순히 객체 생성을 피하기 위해 객체 풀(pool)을 만들지는 않아야 한다.** 물론 데이터베이스 연결과 같이 생성 비용이 워낙 비싸서 재사용하는 것이 나은 경우 객체 풀을 만드는 것이 나을 수 있다. 하지만 일반적으로는 자체 객체 풀은 코드를 헷갈리게 만들고 메모리 사용량을 늘리고 성능을 떨어뜨린다. 요즘 JVM의 가비지 컬렉터는 상당히 잘 최적화되었으므로 가벼운 객체용을 다루는 것은 직접 만든 객체 풀보다 훨씬 빠르다.
- VS 방어적 복사(defensive copy, 아이템 50)
    - 아이템 6 : 기존 객체를 재사용해야 한다면, 새로운 객체를 만들지 마라.
    - 아이템 50 : 새로운 객체를 만들어야 한다면, 기존 객체를 재사용하지 마라.
    - 방어적 복사가 필요한 상황에서 객체를 재사용했을 때의 피해는 필요 없는 객체를 반복 생성했을 때의 피해보다 훨씬 크다!
        - 방어적 복사에 실패한 경우 → 언제 터져 나올지 모르는 버그와 보안 구멍으로 이어진다.
        - 불필요한 객체 생성 → 그저 코드 형태와 성능에만 영향을 준다.

## ✅ 아이템 7 : 다 쓴 객체의 참조를 해제하라.

- C, C++처럼 메모리를 직접 관리해야 하는 언어와 달리, 가비지 컬렉터를 갖춘 언어인 자바는 다 쓴 객체를 알아서 회수해가므로 상당히 편하다.
- 그러면 자바에서는 메모리 관리에 더 이상 신경쓰지 않아도 되는가? No!

### 문제 : 메모리 누수

- 메모리 누수가 발생하는 프로그램을 오래 실행하다 보면 **점차 가비지 컬렉션 활동과 메모리 사용량이 늘어나서 결국 성능이 저하될 것이다.**
- **가비지 컬렉션 언어에서는 (의도치 않게 객체를 살려두는) 메모리 누수를 찾는 것이 아주 까다롭다.**

### 메모리 누수의 주범 1 : 다 쓴 참조

- **다 쓴 참조 (obsolete reference)** : 문자 그대로 앞으로 다시 사용하지 않을 참조를 의미한다.
- 어떤 객체가 객체들의 다 쓴 참조를 여전히 가지고 있다면, 가비지 컬렉터는 다 쓴 참조를 회수해가지 못한다.
- 특히 객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체 뿐 아니라 그 객체가 참조하는 모든 객체, 그리고 그 객체들이 참조하는 모든 객체, …들을 회수해가지 못한다.
- 따라서 **단 몇 개의 객체 때문에 매우 많은 객체를 회수하지 못하는 상황**이 발생할 수 있고, 이로 인해 잠재적으로 성능에 악영향을 줄 수 있다.

### 해결책 : 해당 참조를 다 썼다면 null 처리하여 참조를 해제한다.

- **해당 참조를 다 썼다면 null 처리하여 참조를 해제한다.**
- 다 쓴 참조를 null 처리하면 다른 이점도 있다. 만약 null 처리한 참조를 실수로 사용하려고 하면 프로그램이 즉시 NullPointerException을 던지며 종료된다. 이러한 프로그램 오류는 가능한 한 조기에 발견하는 것이 좋다.
- 이 문제로 크게 데인 적이 있는 프로그래머는 모든 객체를 다 쓰자마자 일일이 null 처리하려고 혈안이 될 것이다. 하지만 그럴 필요도 없고 바람직하지 않으며, 이렇게 하는 것은 오히려 프로그램을 필요 이상으로 지저분하게 만든다.

### 주의 : 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.

- **다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위 밖으로 밀어내는 것이다. 변수의 범위를 최소가 되도록 정의했다면(아이템 57), 이러한 일은 자연스럽게 이뤄진다.**
- 그러면 null 처리는 언제 해야 하는가? 예시의 Stack 클래스가 메모리 누수에 취약한 이유는 바로 Stack이 자기 메모리를 직접 관리하기 때문이다.
- 이 스택은 객체 자체가 아니라 객체의 참조를 담는 elements 배열로 저장소 풀을 만들어서 원소들을 관리한다. 배열의 활성 영역에 속한 원소들이 사용되는 반면, 비활성 영역은 사용되지 않는다.
- 문제는 가비지 컬렉터는 이러한 사실을 알 수가 없다. 가비지 컬렉터 입장에서는 비활성 영역에서 참조하는 객체 또한 유효한 객체로 보이기 때문이다. 즉, 비활성 영역의 객체가 더 이상 쓸모없다는 사실은 가비지 컬렉터는 모르고 프로그래머만 아는 것이다. 따라서 **프로그래머는 비활성 영역이 되는 순간 null 처리함으로써 해당 객체를 더 이상 사용하지 않을 것이라는 사실을 가비지 컬렉터에 알려야 한다.**
- **일반적으로 자기 메모리를 직접 관리하는 클래스라면, 프로그래머는 항상 메모리 누수에 주의해야 한다.** 원소를 다 사용한 즉시 그 원소가 참조한 객체들을 모두 null 처리해야 한다.

### 메모리 누수의 주범 2 : 캐시

- **캐시 역시 메모리 누수를 일으키는 주범이다.**
- 객체 참조를 캐시에 넣은 후, 이 사실을 까맣게 잊은 채 그 객체를 다 쓴 뒤에도 한참을 그냥 놔두는 경우를 자주 접할 수 있다.
- 해결책은 여러 가지가 있다. 운 좋게 캐시 외부에서 key(값이 아니다)를 참조하는 동안만 엔트리가 살아있는 캐시가 필요한 상황이라면, WeekHashMap을 통해 캐시를 만들면 된다. 그러면 다 쓴 엔트리는 그 즉시 자동으로 제거될 것이다. 단, WeekHashMap은 이러한 상황에서만 유용하다는 사실을 기억해야 한다.
- 캐시를 만들 때 보통은 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기 때문에, 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 흔히 사용한다. 이 방식에서는 사용하지 않는 엔트리를 종종 청소해줘야 한다. (ScheduledThreadPoolExecutor 같은) 백그라운드 스레드를 활용하는 방법, 또는 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행하는 방법이 있다. LinkedHashMap은 removeEldestEntry 메서드를 사용하여 후자의 방식으로 처리한다. 더 복잡한 캐시를 만들기 위해서는 java.lang.ref 패키지를 직접 활용해야 할 것이다.

### 메모리 누수의 주범 3 : 리스너(Listener) 또는 콜백(Callback)

- 클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다면, 다른 조치가 없는 한 콜백은 계속 쌓이게 될 것이다.
- 이런 경우에는 콜백을 약한 참조(weak reference)로 저장하면 가비지 컬렉터가 즉시 수거해간다. 예를 들어 WeekHashMap에 키로 저장하면 된다.

## ✅ 아이템 8 : finalizer와 cleaner 사용을 피하라.

- 자바는 두 가지의 객체 소멸자를 제공한다. 바로 finalizer와 cleaner이다.
- **finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어서 일반적으로 불필요하다.**
    - 오동작, 낮은 성능, 이식성 문제의 원인이 되기도 한다.
    - 나름의 쓰임새가 몇 가지 있긴 하지만 기본적으로는 사용하지 말아야 한다.
- 따라서 자바 9에서는 finalizer를 사용 자제(deprecated) API로 지정하고 cleaner를 그 대안으로 소개했다. (하지만 자바 라이브러리에서는 finalizer를 여전히 사용한다)
- **cleaner는 finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.**

### Java의 finalizer와 cleaner VS C++의 파괴자(destructor)

- 자바의 finalizer와 cleaner는 **C++의 파괴자(destructor)와는 다른 개념**이라는 점에 주의해야 한다.
    - C++의 파괴자는 생성자의 꼭 필요한 대척점으로, 특정 객체와 관련된 자원을 회수하는 보편적인 방법이다.
    - 하지만 자바에서는 접근할 수 없게 된 객체를 회수하는 역할을 가비지 컬렉터가 담당하고, 프로그래머에게는 아무런 작업도 요구하지 않는다.
    - C++의 파괴자는 비메모리 자원을 회수하는 용도로도 사용된다.
    - 하지만 자바에서는 try-with-resources와 try-finally를 사용하여 해결한다(아이템 9).

### 문제 1 : finalizer와 cleaner는 즉시 수행된다는 보장이 없다.

- 객체에 접근할 수 없게 된 후 finalizer나 cleaner가 실행되기까지 얼마나 걸릴지 알 수 없다.
- **즉, finalizer와 cleaner로는 제때 실행되어야 하는 작업을 절대 할 수 없다.**
- 예를 들어, 파일 닫기를 finalizer와 cleaner에 맡기면 중대한 오류를 일으킬 수 있다. 시스템이 동시에 열 수 있는 파일의 개수에는 한계가 있는데, 시스템이 finalizer나 cleaner 실행을 게을리하여 파일을 계속 열어둔다면 새로운 파일을 열지 못해 프로그램이 실패할 수 있다.
- finalizer나 cleaner를 얼마나 신속하게 수행할지는 전적으로 가비지 컬렉터 알고리즘에 달렸으며, 이는 가비지 컬렉터의 구현마다 천차만별이다.
- finalizer나 cleaner 수행 시점에 의존하는 프로그램의 동작 또한 마찬가지이다. 우리가 테스트한 JVM에서는 완벽하게 동작하던 프로그램이 가장 중요한 고객의 시스템에서는 엄청난 재앙을 일으킬지도 모른다.

### 문제 2 : finalizer와 cleaner의 수행 시점 뿐만 아니라 수행 여부조차 보장할 수 없다.

- 자바 언어 명세는 finalizer나 cleaner의 **수행 시점 뿐만 아니라 수행 여부조차 보장하지 않는다.** 즉, 접근할 수 없는 일부 객체에 딸린 종료 작업을 전혀 수행하지 못한 채 프로그램이 중단될 수도 있는 것이다.
- 따라서 프로그램 생애주기와 상관없는, **상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존하지 않아야 한다!**
    - 예를 들어, 데이터베이스와 같은 공유 자원의 영구 락(lock) 해제를 finalizer나 cleaner에 맡겨 놓는다면 분산 시스템 전체가 서서히 멈출 것이다.
- `System.gc` 나 `System.runFinalization` 메서드에 현혹되어서는 안된다. finalizer와 cleaner가 실행될 가능성을 높여줄 수는 있지만 여전히 보장해주지는 않는다. 사실 이를 보장해주는 메서드가 2개 있었지만(바로 `System.runFinalizersOnExit` 와 쌍둥이인 `Runtime.runFinalizersOnExit` ), 이 두 메서드는 심각한 결함 때문에 수십 년간 지탄받아 왔다.
- finalizer 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료된다.
    - 잡지 못한 예외 때문에 해당 객체는 자칫 마무리가 덜 된 상태로 남을 수 있으며, 다른 스레드가 이렇게 훼손된 객체를 사용하려 한다면 어떻게 동작할지 예측할 수 없게 된다.
    - 보통의 경우, 잡지 못한 예외는 스레드를 중단시키고 스택 추적 내용을 출력하지만, 같은 일이 finalizer에서 일어난다면 경고조차 출력하지 않는다.
    - 그나마 cleaner를 사용하는 라이브러리는 자신의 스레드를 통제하기 때문에 이러한 문제가 발생하지 않는다.

### 문제 3 : finalizer와 cleaner는 심각한 성능 문제를 동반한다.

- finalizer가 가비지 컬렉터의 효율을 떨어뜨리기 때문이다. 간단한 AutoCloseable 객체를 생성하고 try-with-resources로 자신을 닫도록 해서 가비지 컬렉터가 수거하는 것에 비해, finalizer를 사용한 객체를 생성하고 파괴하는 것이 50배 느린 것으로 측정되었다.
- cleaner 또한 클래스의 모든 인스턴스를 수거하는 형태로 사용하면 finalizer와 성능이 비슷해진다. 단, 안전망 형태로만 사용하면 훨씬 빨라지기는 하나, 여전히 성능이 약 5배 정도 느려지는 것으로 측정되었다.

### 문제 4 : finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.

- finalizer 공격 원리는 간단하다. 생성자나 직렬화 과정(readObject와 readResolve 메서드, 12장 참조)에서 예외가 발생하면, 이 생성되다 만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있게 된다.
- 이는 있어서는 안될 일이다. 이 finalizer는 static 필드에 자신의 참조를 할당하여 가비지 컬렉터가 수집하지 못하도록 막을 수 있다. 이렇게 일그러진 객체가 만들어지면, 이 객체의 메서드를 호출하여 애초에 허용되지 않았을 작업이 수행될 수도 있다.
- **객체 생성을 막기 위해서는 생성자에서 예외를 던지는 것으로 충분하지만, finalizer가 있다면 그렇지 않게 된다.**
- 이러한 공격은 끔찍한 결과를 초래할 수 있다. final 클래스들은 하위 클래스를 만들 수 없으니 이 공격에서 안전하다. **final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하지 않는 finalize 메서드를 만들고 final로 선언해야 한다.**

### 대안 : AutoCloseable을 구현한다.

- 파일이나 스레드 등 종료해야 할 자원을 담고 있는 객체의 클래스에서 finalizer나 cleaner를 사용하는 대신, 그저 **AutoCloseable을 구현**해주고, 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출하면 된다. 이때 일반적으로 예외가 발생해도 제대로 종료되도록 try-with-resources를 사용해야 한다(아이템 9).
- 각 인스턴스는 자신이 닫혔는지 추적하는 것이 좋다. 즉, close 메서드에서 이 객체가 더 이상 유효하지 않음을 필드에 기록하고, 다른 메서드에서 이 필드를 검사하여 객체가 닫힌 후에 불렸다면 IllegalStateException을 던지는 것이다.

## ✅ 아이템 9 : try-finally보다는 try-with-resources를 사용하라.

- 자바 라이브러리에는 close 메서드를 호출하여 직접 닫아줘야 하는 자원들이 많다.
    - `InputStream` , `OutputStream` , `java.sql.Connection` 등
- 자원 닫기는 클라이언트가 놓치기 쉽기 때문에, 예측할 수 없는 성능 문제로 이어지기도 한다.
- 이런 자원 중 상당수가 안전망으로 finalizer를 활용하고는 있지만, finalizer는 그리 믿을 만하지 못하다(아이템 8).

### try-finally의 한계점

- 전통적으로 자원이 제대로 닫히는 것을 보장하는 수단으로 try-finally가 사용되었다. 예외가 발생하거나 메서드에서 반환되는 경우를 포함해서 말이다.
- 이러한 방법은 나쁘지 않다. 그런데 자원을 하나 더 사용한다면? 자원이 둘 이상이면 try-finally 방식은 너무 지저분해지고 실수할 확률이 높아진다!
- 훌륭한 프로그래머조차 잘못을 흔히 저지른다. 심지어 사실 2007년 당시 자바 라이브러리에서 close 메서드를 제대로 구현한 비율이 겨우 1/3 정도라고 한다.
- try-finally 문을 제대로 사용한 코드 예제조차 미묘한 결점이 있다. 예외는 try 블록과 finally 블록 모두에서 발생할 수 있는데, 예를 들어 기기에 물리적인 문제가 생긴다면 readLine 메서드가 예외를 던지고, 같은 이유로 close 메서드도 실패할 것이다. 이때 두 번째 예외가 첫 번째 예외를 완전히 집어삼켜 버리면서, 스택 추적 내역에 첫 번째 예외에 대한 정보는 남지 않게 되어, 실제 시스템에서의 디버깅을 매우 어렵게 한다. (일반적으로 문제를 해결할 때에는 처음 발생한 예외를 보고 싶을 것이다)
    - 물론 두 번째 예외 대신 첫 번째 예외를 기록하도록 코드를 수정할 수는 있지만, 코드가 너무 지저분해져서 실제로 그렇게까지 하는 경우는 거의 없다.

### try-with-resources의 도입

- try-finally의 문제들은 자바 7에서 등장한 try-with-resources 덕에 모두 해결되었다.
- 이 구조를 사용하기 위해서는 해당 자원이 AutoCloseable 인터페이스를 구현해야 한다.
- AutoCloseable 인터페이스 : 단순히 void를 반환하는 close 메서드 하나만 덩그러니 정의한 인터페이스이다.
- 자바 라이브러리와 서드파티 라이브러리들의 수많은 클래스와 인터페이스가 이미 AutoCloseable을 구현하거나 확장해두었다. 만약 닫아야 하는 자원을 의미하는 클래스를 작성해야 한다면, AutoCloseable을 반드시 구현하는 것이 좋다.
- try-with-resources 버전이 짧아서 읽기 편하다. 즉, 문제를 진단하기에도 훨씬 좋다.
- 보통의 try-finally처럼 try-with-resources에서도 catch 절을 사용할 수 있다. catch 절 덕분에 try 문을 더 중첩하지 않고도 다수의 예외를 처리할 수 있다.
