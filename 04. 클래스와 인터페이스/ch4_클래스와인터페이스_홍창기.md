# 이펙티브 자바 4장 : 클래스와 인터페이스

> 출처 : 이펙티브 자바, 3rd Edition
> 2024.06.19. 수 작성

## ✅ 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라.

### (1) 정보 은닉

- 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨서 구현과 API를 깔끔히 분리한다. 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 관심을 갖지 않는다.
- 정보 은닉의 장점
    - 시스템 개발 속도가 빨라진다.
    - 시스템 관리 비용이 낮아진다.
    - 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다.
    - 소프트웨어 재사용성이 높아진다.
    - 큰 시스템을 제작하는 난이도가 낮아진다.

### (2) 기본 원칙 : 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.

- 접근 제한자를 제대로 활용하는 것이 정보 은닉의 핵심이다.
- 소프트웨어가 올바르게 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다.

### (3) 톱레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준

- 종류
    - public : 이 접근제한자로 선언하면 공개 API가 된다. 이들은 API가 되므로 하위 호환을 위해 영원히 관리해주어야 한다.
    - package-private : 이 접근제한자로 선언하면 해당 패키지 안에서만 이용할 수 있다. 이들은 API가 아닌 내부 구현이 되므로 클라이언트에 피해 없이 수정, 교체, 제거할 수 있다.
- 한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 이를 사용하는 클래스 안에 private static으로 중첩시키는 것이 좋다(아이템 24).

### (4) 멤버(필드, 메서드, 중첩 클래스, 중첩 인터페이스)에 부여할 수 있는 접근 수준

- 종류
    - private : 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
    - package-private (default) : 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다. 접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준이다. (단, 인터페이스의 멤버는 기본적으로 public이 적용된다.)
    - protected : package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다. (제약이 조금 따른다)
    - public : 모든 곳에서 접근할 수 있다.
- 순서
    - 클래스의 공개 API를 세심하게 설계한 후, 그 외의 모든 멤버는 private으로 만든다.
    - 이후 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버는 private 제한자를 제거하여 package-private으로 풀어준다.
    - 이때 권한을 풀어주는 일을 자주 하게 된다면 컴포넌트를 더 분해해야 하는 것은 아닌지 다시 고민해야 한다.
- private와 package-private 멤버는 모두 해당 클래스의 구현에 해당하므로 보통은 공개 API에 영향을 주지 않는다. 단, Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수도 있다(아이템 86, 87).
- protected 멤버의 수는 적을수록 좋다.
    - public 클래스에서는 멤버의 접근 수준을 package-private에서 protected로 바꾸는 순간 그 멤버에 접근할 수 있는 대상 범위가 엄청나게 넓어지는데, public 클래스의 protected 멤버는 공개 API이므로 영원히 지원되어야 하며, 내부 동작 방식을 API 문서에 적어서 사용자에게 공개해야 할 수도 있기 때문이다(아이템 19).
- 멤버 접근성을 좁히지 못하게 방해하는 제약이 하나 있는데, 바로 상위 클래스의 메서드를 재정의할 때 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다는 것이다. 이 제약은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해서 사용할 수 있어야 한다는 규칙(리스코프 치환 법칙)을 지키기 위해 필요하다.
- 단순한 코드 테스트 목적으로 클래스, 인터페이스, 멤버의 접근 범위를 넓히려 할 때, 적당한 수준까지 넓히는 것은 괜찮고, 테스트만을 위해서 공개 API로 만들어서는 안된다.
- **public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다(아이템 16). (public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다)**
- **클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.** 길이가 0이 아닌 배열은 모두 변경할 수 있기 때문이다.
    - 해결책 1 : 배열을 private으로 만들고 public 불변 리스트를 추가한다.
    - 해결책 2 : 배열을 private으로 만들고 그 복사본을 반환하는 public 메서드를 추가한다. (방어적 복사)

### (5) Java 9의 모듈 시스템 개념 도입 후

- 패키지가 클래스들의 묶음이듯, 모듈은 패키지들의 묶음이다. 모듈은 자신에 속하는 패키지 중 공개(export)할 것들을 (관례상 module-info.java 파일에) 선언한다. protected 또는 public 멤버라도 해당 패키지를 공개하지 않았다면 모듈 외부에서는 접근할 수 없다.
- 모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있다.

## ✅ 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.

- **패키지 바깥에서 접근할 수 있는 클래스, 즉 public 클래스에서는 필드를 모두 private으로 바꾸고 public 접근자(getter)를 추가한다.**
    - 데이터 필드에 직접 접근할 수 있게 하면, API를 수정하지 않고는 내부 표현을 바꿀 수 없고, 불변식을 보장할 수 없고, 외부에서 필드에 접근할 때 부수 작업을 수행할 수 없는 등 캡슐화의 이점을 제공하지 못하기 때문이다(아이템 15).
- package-private 클래스 또는 private 중첩 클래스라면 데이터 필드를 노출한다고 해도 이러한 문제가 없다. 이 방식에서는 클래스 선언 면에서나 이를 사용하는 클라이언트 코드 면에서나 접근자 방식보다 훨씬 깔끔하다는 장점이 있다.

## ✅ 아이템 17. 변경 가능성을 최소화하라.

### (1) 불변 클래스

- **불변 클래스 : 인스턴스의 내부 값을 수정할 수 없는 클래스**
    - 자바 플랫폼 라이브러리에도 다양한 불변 클래스가 있다. ex) String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal

### (2) 불변 클래스의 장점

- **가변 클래스보다 설계하고 구현하고 사용하기 쉽다.**
- **오류가 생길 여지가 적고, 훨씬 안전하다.**

### (3) 클래스를 불변으로 만들기 위한 5가지 규칙

1. 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
3. 모든 필드를 final로 설정한다.
4. 모든 필드를 private으로 설정한다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

### (4) 불변 객체의 특징

- **불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요가 없다.** 따라서 불변 객체는 안심하고 공유할 수 있다.
- **불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.**
- **객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.**
    - 값이 바뀌지 않는 구성요소들로 이루어진 객체라면 그 구조가 아무리 복잡하더라도 불변식을 유지하기가 훨씬 수월하기 때문이다.
    - 좋은 예시로, 불변 객체는 맵의 키와 집합의 원소로 사용하기에 안성맞춤이다.
- **불변 객체는 그 자체로 실패 원자성을 제공한다(아이템 76).** 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다.

### (4) 불변 클래스의 단점

- **값이 다르면 반드시 독립된 객체로 만들어야 하는데, 이 때문에 값의 가짓수가 많다면 이들을 모두 만드는 데 큰 비용이 들어간다.**
    - 해결책 1 : 클라이언트들이 원하는 복잡한 연산을 정확하게 예측할 수 있다면 **package-private의 가변 동반 클래스(companion class)**만으로 충분하다. 흔히 사용되는 다단계 연산(multistep operation)을 예측하여 기본 기능으로 제공하는 방법으로, 이렇게 하면 각 단계마다 객체를 생성하지 않아도 되기 때문이다. 대표적인 예시로 BigInteger가 있다.
        - BigInteger의 연산에서 발생하는 불변 클래스의 단점을 개선하기 위해, BigInteger에서는 모듈러 지수 같은 다단계 연산 속도를 높여주는 가변 동반 클래스를 package-private으로 두고 있다.
    - 해결책 2 : 클라이언트들이 원하는 복잡한 연산을 정확하게 예측할 수 없는 경우, 이 클래스를 public으로 제공하는 것이 최선이다. 자바 플랫폼 라이브러리에서 이에 해당하는 대표적인 예시가 바로 String 클래스이다.
        - String의 가변 동반 클래스는 바로 StringBuilder(와 구닥다리 전임자 StringBuffer)이다.

### (5) 요약

- **클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.**
- 모든 클래스를 불변으로 만들 수 있는 것은 아니다. **불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄여야 한다.**
- 아이템 15와 16을 종합하면 다음과 같다 : **다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.**
- **생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.**

## ✅ 아이템 18. 상속보다는 컴포지션을 사용하라.

### (1) 상속은 항상 최선의 수단인가?

- 상속은 코드를 재사용하는 강력한 수단이다.
- 그러나 항상 최선은 아니다. 잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 되기 때문이다.
- 상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서라면, 또는 확장할 목적으로 설계되었고 문서화도 잘 된 클래스(아이템 19)라면, 상속은 안전한 방법이다.
- 그러나 일반적인 구체 클래스를 패키지 경계를 넘어 상속하는, 즉 다른 패키지의 구체 클래스를 상속하는 일은 위험하다.
- **메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.**
    - 즉, 상위 클래스에서 릴리스마다 내부 구현이 달라지는 여파로, 코드 한 줄 건드리지 않은 하위 클래스가 오동작할 수 있다.
    - 이러한 이유로 상위 클래스 설계자가 확장을 충분히 고려하고 문서화도 제대로 해두지 않으면 하위 클래스는 상위 클래스의 변화에 발맞춰 수정되어야 한다.

### (2) 기존 클래스를 확장하는 대신, 컴포지션을 사용하자.

- 컴포지션(composition) : 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하는 방식이다. 즉, 기존 클래스를 새로운 클래스의 구성요소로 사용하는 설계 방식이다.
- 전달 (forwarding), 전달 메서드(forwarding method) : 새로운 클래스의 인스턴스 메서드들은 (private 필드로 참조하는) 기존 클래스의 대응하는 메서드를 호출하여 그 결과를 반환하는데, 이러한 방식을 전달(forwarding)이라 하며, 새로운 클래스의 메서드들을 전달 메서드(forwarding method)라고 한다.
- 컴포지션 방식의 장점 : 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향받지 않는다.

## ✅ 아이템 19. 상속을 고려하여 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

### (1) 상속을 고려한 설계와 문서화가 무엇인가?

- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
    - 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.
    - 클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 때 호출되는 메서드가 재정의 가능 메서드라면, 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다. 게다가 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다. (여기서 재정의 가능 메서드는 public과 protected 메서드 중 final이 아닌 모든 메서드를 의미한다)
    - 더 넓게 말하면, 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
    - API 문서의 메서드 설명 끝에서 종종 "Implementation Requirements"로 시작하는 절을 볼 수 있는데, 바로 메서드의 내부 동작 방식을 설명하는 곳이다. 이 절은 메서드 주석에 @ImplSpec 태그를 붙여주면 자바독 도구가 생성한다. @ImplSpec 태그는 자바 8에서 처음 도입되어 자바 9부터 본격적으로 시작되기 시작했다. 이 태그가 기본값으로 활성화되어야 바람직하다고 생각되지만, 자바 11의 자바독에서도 여전히 선택사항으로 남겨져있다.
- 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 **클래스의 내부 동작 과정에 끼어들 수 있는 훅(hook)을 잘 선별해서 protected 메서드 형태로 공개해야 한다.**

### (2) 상속용 클래스의 설계

- 상속용 클래스를 설계할 때 어떤 메서드를 protected로 노출해야 할지는 어떻게 결정하는가?
    - 안타깝게도 마법은 없고, 잘 예측해본 다음 실제 하위 클래스를 만들어서 시험해보는 것이 최선이다.
- **상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.**
- **상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.**
    - 널리 사용될 클래스를 상속용으로 설계한다면, 문서화한 내부 사용 패턴과, protected 메서드와 필드를 구현하면서 선택한 결정에 영원히 책임져야 한다는 것을 잘 인식해야 한다. 이 결정들은 그 클래스의 성능과 기능에 영원한 족쇄가 될 수 있다.
- **상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.**
    - 이 규칙을 어기면 프로그램이 오동작할 것이다.
- **clone과 readObject 메서드 또한 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.**
    - clone과 readObject 메서드는 생성자와 비슷한 효과를 내기 때문이다(새로운 객체를 만든다).
- Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 이 메서드들은 private이 아닌 protected로 선언해야 한다. private로 선언한다면 하위 클래스에서 무시되기 때문이다.

### (3) 문제를 해결하는 가장 좋은 방법

- 문제를 해결하는 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다.
    - 해결책 1 : 둘 중 더 쉬운 쪽의 클래스를 final로 선언하는 방법이다.
    - 해결책 2 : 모든 생성자를 private이나 package-private으로 선언하고 public static 팩토리를 만들어주는 방법이다.

## ✅ 아이템 20. 추상 클래스보다는 인터페이스를 우선하라.

### (1) 추상 클래스와 인터페이스

- 자바가 제공하는 다중 구현 메커니즘 2가지 : 추상 클래스, 인터페이스
- 자바 8부터 인터페이스도 디폴트 메서드(default method)를 제공할 수 있게 되었다. 따라서 이제는 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있다.

### (2) 인터페이스의 장점

- 자바는 단일 상속만 지원하므로, 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다. 반면, 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.
- **인터페이스는 믹스인(mixin) 정의에 안성맞춤이다.**
    - 믹스인 : 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 주된 타입 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.
- **인터페이스를 통해 계층구조가 없는 타입 프레임워크를 만들 수 있다.**
- 래퍼 클래스 관용구(아이템 18)와 함께 사용하면 **인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.**
    - 인터페이스가 아니라 추상 클래스로 타입을 정의하면 그 타입에 기능을 추가하는 방법은 상속 뿐인데, 상속해서 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기는 더 쉽다.

### (3) 디폴트 메서드의 제약

- equals와 hashCode 같은 Object의 메서드들은 디폴트 메서드로 제공해서는 안된다.
- 인터페이스는 인스턴스 필드를 가질 수 없고, public이 아닌 static 멤버를 가질 수 없다. 단, private static 메서드는 예외이다.
- 내가 만들지 않은 인터페이스에는 디폴트 메서드를 추가할 수 없다.

### (4) 템플릿 메서드 패턴

- 인터페이스와 추상 골격 구현(skeletal implementation) 클래스를 함께 제공하는 방식으로, 인터페이스와 추상 클래스의 장점을 모두 취하는 방법이다.
- 인터페이스로는 타입을 정의하고, 필요하면 디폴트 메서드 몇 개도 함께 제공한다. 그리고 골격 구현 클래스는 나머지 메서드들까지 구현한다.
- 관례상 인터페이스 이름이 Interface라면, 그 골격 구현 클래스의 이름은 AbstractInterface로 짓는다.

## ✅ 아이템 21. 인터페이스는 구현하는 쪽을 생각하여 설계하라.

- 디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 사용된다.
- 자바 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되였다. 하지만 **생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하는 것은 어려운 일이다.**
- **디폴트 메서드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다.** 흔한 일은 아니지만, 그렇다고 해서 일어나지 않으리라는 보장도 없다.
- 디폴트 메서드라는 도구가 생겼더라도, 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.

## ✅ 아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용하라.

- 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다.
- 상수 인터페이스 : 메서드 없이, 상수를 의미하는 static final 필드로만 가득 찬 인터페이스
- 상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예시이다.
    - 클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당한다. 따라서 상수 인터페이스를 구현하는 것은 이 내부 구현을 클래스의 API로 노출하는 행위다.
    - 클래스가 어떤 상수 인터페이스를 사용하든 사용자에게는 아무런 의미가 없고, 오히려 사용자에게 혼란을 주기도 하며, 클라이언트 코드가 내부 구현에 해당하는 이 상수들에 종속되게 한다.
- 상수를 공개할 목적이라면 더 합당한 선택지가 몇 가지 있다.
    - 특정 클래스나 인터페이스와 강하게 연관된 상수라면, 그 클래스나 인터페이스 자체에 추가해야 한다.
    - 열거 타입으로 나타내기 적합한 상수라면, 열거 타입으로 만들어 공개해야 한다(아이템 34).
    - 위의 2가지 모두 아니라면, 인스턴스화할 수 없는 유틸리티 클래스(아이템 4)에 담아서 공개해야 한다.

## ✅ 아이템 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라.

### (1) 태그 달린 클래스는 장황하고, 오류가 발생하기 쉽고, 비효율적이다.

- 태그 달린 클래스에는 여러 구현이 한 클래스에 혼합되어 있기 때문에 가독성이 나쁘다.
- 열거 타입 선언, 태그 필드, switch 문 등 쓸데없는 코드가 많으며, 다른 의미를 위한 코드도 언제나 함께 하므로 메모리를 많이 사용한다.
- 필드들을 final로 선언하려면 현재 인스턴스의 의미에서 사용되지 않는 필드들까지 생성자에서 초기화해야 하므로 불필요한 코드가 늘어난다.
- 인스턴스의 타입만으로는 이 인스턴스가 현재 나타내는 의미를 전혀 알 수 없다.

### (2) 태그 달린 클래스를 클래스 계층구조로 바꾸는 방법

- 가장 먼저 계층구조의 루트가 될 추상 클래스를 정의한다. 그리고 태그 값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언한다.
- 그런 다음 태그 값에 상관없이 동작이 일정한 메서드들을 루트 클래스에 일반 메서드로 추가한다.
- 모든 하위 클래스에서 공통으로 사용하는 데이터 필드들도 전부 루트 클래스로 올린다.
- 다음으로, 루트 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의한다. 각 하위 클래스에는 각자의 의미에 해당하는 데이터 필드들을 넣고, 그 다음으로 루트 클래스가 정의한 추상 메서드를 각자의 의미에 맞게 구현한다.

## ✅ 아이템 24. 멤버 클래스는 되도록 static으로 만들라.

### (1) 중첩 클래스 (nested class)

- 중첩 클래스 (nested class) : 다른 클래스 안에서 정의된 클래스
- 중첩 클래스는 자신을 감싼 바깥 클래스에서만 사용되어야 하며, 그 외의 쓰임새가 있다면 중첩 클래스가 아니라 톱레벨 클래스로 만들어야 한다.
- 중첩 클래스의 종류
    - static 멤버 클래스
    - (non-static) 멤버 클래스
    - 익명 클래스
    - 지역 클래스
- 위의 4가지 종류 중 static 멤버 클래스를 제외한 나머지는 내부 클래스(inner class)에 해당한다.

### (2) 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면, 무조건 static을 붙여서 static 멤버 클래스로 만들자.

- static 멤버 클래스는 다른 클래스 안에서 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하면 일반 클래스와 같다.
- static 멤버 클래스와 non-static 멤버 클래스의 의미상 차이는 의외로 꽤 크다. non-static 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다. 그래서 non-static 멤버 클래스의 인스턴스 메서드에서 정규화된 this를 사용하여 바깥 인스턴스를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있다.
- 따라서 개념상 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 static 멤버 클래스로 만들어야 한다.

### (3) 익명 클래스

- 익명 클래스는 응용하는 데 제약이 많다.
- 선언한 지점에서만 인스턴스를 만들 수 있고, instanceof 검사나 클래스의 이름이 필요한 작업은 수행할 수 없다.
- 여러 인터페이스를 구현할 수 없고, 인터페이스를 구현하는 동시에 다른 클래스를 상속할 수 없다.

### (4) 지역 클래스

- 4가지 중첩 클래스 중 가장 드물게 사용된다.
- 지역 클래스는 지역 변수를 선언할 수 있는 곳이면 실질적으로 어디서든 선언할 수 있고, 유효 범위도 지역변수와 같다.
- 멤버 클래스처럼 이름이 있고 반복해서 사용할 수 있다.
- 익명 클래스처럼 non-static 문맥에서 사용될 때에만 바깥 인스턴스를 참조할 수 있으며, static 멤버는 가질 수 없으며, 가독성을 위해 짧게 작성해야 한다.

## ✅ 아이템 25. 톱레벨 클래스는 한 파일에 하나만 담아라.

- 소스 파일 하나에 톱레벨 클래스를 여러 개 선언하더라도 자바 컴파일러에서 오류가 발생하지는 않는다. 하지만 아무런 이득이 없을 뿐더러 심각한 위험을 감수해야 한다.
    - 이렇게 하면 하나의 클래스를 여러 가지로 정의할 수 있는데, 그 중 어느 것을 사용할지는 어느 소스 파일을 먼저 컴파일하는지에 따라 달라지기 때문이다.
- 해결책은 정말 간단하다. 톱레벨 클래스들을 서로 다른 소스 파일로 분리하면 된다.
