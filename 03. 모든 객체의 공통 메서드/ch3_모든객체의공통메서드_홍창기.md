# 이펙티브 자바 3장 : 모든 객체의 공통 메서드

> 출처 : 이펙티브 자바, 3rd Edition
> 2024.06.16. 일 작성

## ✅ 아이템 10. `equals` 는 일반 규약을 지켜서 재정의하라.

### (1) `equals` 메서드를 재정의하지 않아야 하는 경우

- 각 인스턴스가 본질적으로 고유한 경우
    - 값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스가 여기에 해당한다.
    - 예시 : Thread
- 인스턴스의 논리적 동치성(logical equality)을 검사할 일이 없는 경우
- 상위 클래스에서 재정의한 `equals` 메서드가 하위 클래스에서도 딱 들어맞는 경우
    - 예를 들어, 대부분의 Set 구현체는 AbstractSet이 구현한 `equals` 를 상속받아 사용하고, List 구현체는 AbstractList로부터, Map 구현체는 AbstractMap으로부터 `equals` 를 상속받아 그대로 사용한다.
- 클래스가 private이거나 package-private이고 `equals` 메서드를 호출할 일이 없는 경우

### (2) `equals` 메서드를 재정의해야 하는 경우

- 객체 식별성이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 `equals` 메서드가 논리적 동치성을 비교하도록 재정의되지 않은 경우 (즉, 두 객체가 물리적으로 같은지가 아니라 값이 같은지를 알고 싶은 경우)
    - 여기서 객체 식별성 (Object Identity)이란, 두 객체가 물리적으로 같은지를 의미하는 개념이다.
    - 주로 값을 표현하는 클래스인 값 클래스들이 이 경우에 해당한다. ex) `Integer` , `String`
    - 값 클래스이지만 인스턴스 통제 클래스(아이템 1) 또는 Enum(아이템 34)처럼 값이 같은 인스턴스가 둘 이상 만들어지지 않는 것이 보장되는 클래스라면 `equals` 를 재정의하지 않아도 된다.

### (3) `equals` 메서드를 재정의할 때 반드시 따라야 하는 일반 규약

- 아래 규약은 Object 명세에 적힌 규약이다.
- `equals` 메서드는 동치관계(equivalence relation)를 구현하며, 다음을 만족한다.
    - 반사성 (reflexivity) : null이 아닌 모든 참조 값 `x` 에 대해, `x.equals(x)` 는 `true` 이다.
    - 대칭성 (symmetry) : null이 아닌 모든 참조 값 `x` , `y` 에 대해, `x.equals(y)` 가 `true` 이면, `y.eqauls(x)` 도 `true` 이다.
    - 추이성 (transitivity) : null이 아닌 모든 참조 값 `x` , `y` , `z` 에 대해, `x.equals(y)` 가 `true` 이고 `y.eqauls(z)` 가 `true` 이면, `x.equals(z)` 도 `true` 이다.
    - 일관성 (consistency) : null이 아닌 모든 참조 값 `x` , `y` 에 대해, `x.equals(y)` 를 반복해서 호출하면 항상 `true` 를 반환하거나 항상 `false` 를 반환한다.
    - null-아님 : null이 아닌 모든 참조 값 `x` 에 대해, `x.equals(null)` 은 `false` 이다.
- `equals` 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없게 된다는 문제가 발생한다.

### (4) 양질의 `equals` 메서드 구현 방법을 단계별로 정리하기

1. `==` 연산자를 사용하여 입력이 자기 자신의 참조인지 확인한다.
    - 자기 자신이면 `true` 를 반환한다.
    - 이 단계는 단순한 성능 최적화를 위한 것으로, 비교 작업이 복잡한 상황에서 값어치를 한다.
2. `instanceof` 연산자를 사용하여 입력이 올바른 타입인지 확인한다.
    - 그렇지 않다면 `false` 를 반환한다.
    - 입력이 null이면 타입 확인 단계에서 `false` 를 반환하므로 null 검사를 명시적으로 하지 않아도 된다.
    - 이때의 올바른 타입은 보통 `equals` 가 정의된 클래스이지만, 가끔은 그 클래스가 구현한 인터페이스가 될 수도 있다.
        - 어떤 인터페이스는 자신을 구현한 (서로 다른) 클래스끼리도 비교할 수 있도록 `equals` 규약을 수정하기도 하며, 이런 인터페이스를 구현한 클래스는 `equals` 에서 자신의 클래스가 아닌 해당 인터페이스를 사용해야 한다.
        - 예시 : Set, List, Map, Map.Entry 등의 컬렉션 인터페이스
3. 입력을 올바른 타입으로 형 변환한다.
    - 앞서 2번 단계에서 `instanceof` 검사를 했기 때문에 이 단계는 100% 성공한다.
4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사한다.
    - 모든 필드가 일치한다면 `true` 를, 하나라도 다르면 `false` 를 반환한다.
    - 앞서 2번 단계에서 인터페이스를 사용했다면 입력의 필드 값을 가져올 때도 그 인터페이스의 메서드를 사용해야 한다.
    - 타입이 클래스라면 (접근 권한에 따라) 해당 필드에 직접 접근할 수도 있다.

### (5) 필드 비교 방법 및 주의사항

- float와 double을 제외한 기본 타입 필드는 `==` 연산자로 비교한다.
- 참조 타입 필드는 각각의 `equals` 메서드로 비교한다.
- float와 double 필드는 각각 static 메서드인 `Float.compare(float, float)` 와 `Double.compare(double, double)` 로 비교한다.
    - float와 double을 특별하게 취급하는 이유는 `Float.NaN` , `-0.0f` , 특수한 부동소수 값 등을 다루어야 하기 때문이다.
    - `Float.equals` 와 `Double.equals` 메서드를 대신 사용할 수도 있지만, 이 메서드들은 오토박싱을 수반할 수 있으므로 성능상 좋지 않다.
- 배열 필드는 원소 각각을 위의 지침대로 비교한다.
- 배열의 모든 원소가 핵심 필드라면 `Arrays.equals` 메서드들 중 하나를 사용한다.
- 때때로 null을 정상 값으로 취급하는 참조 타입 필드도 있다. 이러한 경우에는 NullPointerException 발생을 예방하기 위해 이러한 필드는 static 메서드인 `Object.equals(Object, Object)` 로 비교한다.
- `CaseIntensitiveString` 의 예시처럼 비교하기가 아주 복잡한 필드를 가진 클래스도 있다. 이러한 경우에는 그 필드의 표준형(canonical form)을 저장해둔 후 표준형끼리 비교하면 훨씬 경제적이다.
- 어떤 필드를 먼저 비교하는지에 따라 `equals` 의 성능이 달라지기도 한다. 최상의 성능을 내기 위해서는 다를 가능성이 크거나 비교하는 비용이 싼 필드를 먼저 비교해야 한다.
- 동기화용 락(lock) 필드처럼 객체의 논리적 상태와 관련 없는 필드는 비교하지 않아야 한다.
- 핵심 필드로부터 계산할 수 있는 파생 필드 역시 굳이 비교할 필요는 없다. 하지만 파생 필드를 비교하는 쪽이 더 빠른 경우도 있다. 파생 필드가 객체 전체의 상태를 대표하는 상황이 그렇다.

### (6) `equals` 구현 완료 후 자문해야 할 3가지 사항

1. **대칭적인가?**
2. **추이성이 있는가?**
3. **일관적인가?**
- 자문에서 끝내지 말고 단위 테스트를 작성하여 돌려봐야 한다.
- 3가지 요건 중 하나라도 실패한다면 원인을 찾아서 고쳐야 한다.
- 나머지 요건인 반사성과 null-아님도 만족해야 하지만, 이 2가지 요건이 문제되는 경우는 별로 없다.

### (7) 마지막 주의사항

- **`equals` 를 재정의할 때는 `hashCode` 도 반드시 재정의해야 한다.** (아이템 11)
- **너무 복잡하게 해결하려고 하지 말아야 한다.**
    - 필드의 동치성만 검사해도 `equals` 규약을 어렵지 않게 지킬 수 있다.
    - 예를 들어, File 클래스라면 심볼릭 링크를 비교하여 같은 파일을 가리키는지를 확인하려 들면 안 된다. 다행히 File 클래스는 이런 시도를 하지 않는다.
- Object 외의 타입을 매개변수로 받는 `equals` 메서드는 선언하지 않아야 한다.

## ✅ 아이템 11. `equals` 를 재정의하려거든 `hashCode` 도 재정의하라.

### (1) `equals` 를 재정의한 클래스 모두에서 `hashCode` 도 재정의해야 한다.

- 그렇지 않으면 `hashCode` 일반 규약을 어기게 되어, 해당 클래스의 인스턴스를 `HashMap` 이나 `HashSet` 과 같은 컬렉션의 원소로 사용할 때 문제가 발생할 것이다.
- 다음은 Object 명세에서 발췌한 규약이다.
    - `equals` 비교에 사용되는 정보가 변경되지 않았다면, 어플리케이션이 실행되는 동안 그 객체의 `hashCode` 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 어플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
    - `equals(Object)` 가 두 객체를 같다고 판단했다면, 두 객체의 `hashCode` 는 같은 값을 반환해야 한다.
    - `equals(Object)` 가 두 객체를 다르다고 판단했더라도, 두 객체의 `hashCode` 가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.
- `hashCode` 재정의를 잘못한 경우 크게 문제가 되는 조항은 2번째 조항이다. 즉, **논리적으로 같은 객체는 반드시 같은 해시코드를 반환해야 한다.**

### (2) 좋은 `hashCode` 를 작성하는 간단한 요령

- 좋은 해시 함수라면 서로 다른 인스턴스에 의해 다른 해시코드를 반환해야 한다. 이것이 바로 `hashCode` 의 3번째 규약이 요구하는 속성이다.
- 이상적인 해시 함수는 주어진 (서로 다른) 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.
- 다음은 좋은 `hashCode` 를 작성하는 간단한 요령이다.
    1. int 변수 `result` 를 선언한 후 값 `c` 로 초기화한다. 이때 `c` 는 해당 객체의 첫번째 핵심 필드를 단계 2.a 방식으로 계산한 해시코드이다. (여기서 핵심 필드란 `equals` 비교에 사용되는 필드를 의미한다, 아이템 10)
    2. 해당 객체의 나머지 핵심 필드 `f` 각각에 대해 다음 작업을 수행한다.
        1. 해당 필드의 해시코드 `c` 를 계산한다.
            1. 기본 타입 필드라면, `Type.hashCode(f)` 를 수행한다. 여기서 `Type` 은 해당 기본 타입의 박싱 클래스이다.
            2. 참조 타입 필드면서 이 클래스의 `equals` 메서드가 이 필드의 `equals` 를 재귀적으로 호출하여 비교한다면, 이 필드의 `hashCode` 를 재귀적으로 호출한다. 계산이 더 복잡해질 것 같으면, 이 필드의 표준형(canonical representation)을 만들어서 그 표준형의 `hashCode` 를 호출한다. 필드의 값이 null이면 0을 사용한다. (다른 상수를 사용해도 괜찮지만 전통적으로 0을 사용한다)
            3. 필드가 배열이라면, 핵심 원소 각각을 별도의 필드처럼 다룬다. 이상의 규칙을 재귀적으로 적용하여 각 핵심 원소의 해시코드를 계산한 다음, 단계 2.b 방식으로 갱신한다. 배열에 핵심 원소가 하나도 없다면, 단순히 상수(0을 추천한다)를 사용한다. 모든 원소가 핵심 원소라면 `Arrays.hashCode` 를 사용한다.
        2. 단계 2.a에서 계산한 해시코드 `c` 로 `result` 를 갱신한다. 다음과 같은 코드이다.
            - `result = 31 * result + c;`
    3. `result` 를 반환한다.
- `hashCode` 를 다 구현했다면 이 메서드가 동치인 인스턴스에 대해 동일한 해시코드를 반환하는지 자문해야 한다. 그리고 우리의 직관을 검증할 단위 테스트를 작성해야 한다. 동치인 인스턴스가 서로 다른 해시코드를 반환한다면 원인을 찾아 해결한다.
- 파생 필드는 해시코드 계산에서 제외해도 된다. 즉, 다른 필드로부터 계산해낼 수 있는 필드는 모두 무시해도 된다.
- **`equals` 비교에 사용되지 않은 필드는 반드시 제외해야 한다!** 그렇지 않으면 `hashCode` 규약의 2번째 조항을 어기게 될 위험이 있다.
- Object 클래스는 임의의 개수만큼 객체를 받아서 해시코드를 계산해주는 static 메서드인 `hash` 를 제공한다. 이 메서드를 활용하면 앞의 요령대로 구현한 코드와 비슷한 수준의 `hashCode` 함수를 단 한 줄로 작성할 수 있다. 그러나 아쉽게도 속도는 더 느리다. 입력 인수를 담기 위한 배열이 만들어지고, 입력 중 기본 타입이 있다면 박싱과 언박싱도 거쳐야 하기 때문이다. 따라서 `hash` 메서드는 성능에 민감하지 않은 상황에서만 사용해야 한다.
- 클래스가 불변이고 해시코드를 계산하는 비용이 크다면, 매번 새로 계산하기보다는 캐싱하는 방식을 고려해야 한다. 이 타입의 객체가 주로 해시의 키로 사용될 것 같다면 인스턴스가 만들어질 때 해시코드를 계산해둬야 한다.
- 이 타입의 객체가 주로 해시의 키로 사용되지 않는다면, `hashCode` 가 처음 불릴 때 계산하는 지연 초기화(lazy initialization) 전략을 생각할 수 있다. 필드를 지연 초기화하려면 그 클래스를 스레드 안전하게 만들도록 신경써야 한다(아이템 83). 이때 `hashCode` 의 초깃값은 흔히 생성되는 객체의 해시코드와는 달라야 한다는 점에 유의해야 한다.
- **성능을 높인다는 이유로 해시코드를 계산할 때 핵심 필드를 생략해서는 안된다.** 속도는 빨라지겠지만, 해시 품질이 나빠져서 해시테이블의 성능을 심각하게 떨어뜨릴 수도 있다.
- **`hashCode` 가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말아야 한다.** 그래야 클라이언트가 이 값에 의존하지 않게 된다. 또한 자세한 규칙을 공표하지 않는다면, 해시 기능에서 결함을 발견한 경우 또는 더 나은 해시 방식을 알아낸 경우에 다음 릴리스에서 계산 방식을 수정할 수 있게 된다.

## ✅ 아이템 12. `toString` 을 항상 재정의하라.

- `toString` 의 일반 규약
    - `toString` 메서드는 간결하면서 사람이 읽기 쉬운 형태의 유익한 정보를 반환해야 한다.
    - 모든 하위 클래스에서 `toString` 메서드를 재정의해야 한다.
- `equals` 와 `hashCode` 규약(아이템 10, 11)만큼 대단히 중요하지는 않다. 하지만 **`toString` 을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.**
    - `toString` 메서드는 객체를 `println` , `printf` , 문자열 연결 연산자 `+` , `assert` 구문에 넘길 때, 디버거가 객체를 출력할 때 자동으로 호출된다. 즉, 우리가 직접 호출하지 않더라도 다른 어딘가에서 사용된다.
- **실전에서 `toString` 메서드는 그 객체가 가진 주요 정보 모두를 반환하는 것이 좋다.**
    - 객체가 거대한 경우, 또는 객체의 상태가 문자열로 표현하기에 적합하지 않은 경우에는 주요 정보 모두를 반환하기에 무리가 있다. 이러한 경우에는 요약 정보를 담아서 반환해야 한다.
    - 이상적으로는 스스로를 완벽히 설명하는 문자열을 반환해야 한다.
- `toString` 을 구현할 때에는 반환값의 포맷을 문서화할지 정해야 한다. 이는 아주 중요한 선택이다. 특히 전화번호나 행렬과 같은 값 클래스라면 문서화하는 것을 권장한다.
    - 포맷을 명시하면 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다. 따라서 그 값 그대로 입출력에 사용하거나 CSV 파일처럼 사람이 읽을 수 있는 데이터 객체로 저장할 수도 있다.
    - 포맷을 명시하기로 했다면, 명시한 포맷에 맞는 문자열과 객체를 상호 전환할 수 있는 static 팩토리나 생성자를 함께 제공해주는 것이 좋다. 이는 자바 플랫폼의 많은 값 클래스들이 따르는 방식이기도 하다. ex) BigInteger, BigDecimal, 대부분의 기본 타입 클래스
    - 단점도 있는데, 포맷을 한번 명시하면 (그 클래스가 많이 사용된다면) 평생 그 포맷에 얽매이게 된다는 단점이다. 이를 사용하는 프로그래머들은 그 포맷에 맞춰서 파싱하고, 새로운 객체를 만들고, 영속 데이터로 저장하는 코드를 작성할 것이다. 이러한 상황에서 만약 향후 릴리스에서 포맷을 변경한다면, 이를 사용하던 코드들과 데이터들은 엉망이 될 것이다.
    - 반대로 포맷을 명시하지 않는다면, 향후 릴리스에서 정보를 더 넣거나 포맷을 개선할 수 있는 유연성을 얻게 된다.
- **포맷을 명시하든, 명시하지 않든, 그 의도는 명확하게 밝혀야 한다.** 또한 포맷을 명시하려면 아주 정확하게 명시해야 한다. 포맷을 명시하지 않는다면 그러한 의도를 명확하게 밝혀야 한다.

    ```java
    /**
     * 이 전화번호의 문자열 표현을 반환한다.
     * 이 문자열은 "XXX-YYY-ZZZZ" 형태의 12글자로 구성된다.
     * XXX는 지역 코드, YYY는 프리픽스, ZZZZ는 가입자 번호다.
     * 각각의 대문자는 10진수 숫자 하나를 가리킨다.
     *
     * 전화번호의 각 부분의 값이 너무 작아서 자릿수를 채울 수 없다면,
     * 앞에서부터 0으로 채워나간다. 예를 들어 가입자 번호가 123이라면
     * 전화번호의 마지막 네 문자는 "0123"이 된다.
     */
    @Override public String toString() {
        return String.format("%03d-%03d-%04d",
                areaCode, prefix, lineNum);
    }
    ```

    ```java
    /**
     * 이 약물에 관한 대략적인 설명을 반환한다.
     * 다음은 이 설명의 일반적인 형태이나,
     * 상세 형식은 정해지지 않았으며 향후 변경될 수 있다.
     *
     * "[약물 #9: 유형=사랑, 냄새=테레빈유, 겉모습=먹물]"
     */
    @Override public String toString() { ... }
    ```

- 포맷 명시 여부와 상관없이 **`toString` 이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공해야 한다.**
- static 유틸리티 클래스(아이템 4)는 `toString` 을 제공할 이유가 없다. 또한 대부분의 열거 타입(아이템 34)도 자바가 이미 완벽한 `toString` 을 제공하고 있으므로 따로 재정의하지 않아도 된다. 하지만 하위 클래스들이 공유해야 할 문자열 표현이 있는 추상 클래스라면 `toString` 을 재정의해야 한다. 예를 들어 대다수의 컬렉션 구현체는 추상 컬렉션 클래스들의 `toString` 메서드를 상속하여 사용한다.

## ✅ 아이템 13. `clone` 재정의는 주의해서 진행하라.

### (1) `Cloneable` 인터페이스의 문제점

- `Cloneable` 인터페이스는 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스(mixin interface, 아이템 20)이다.
- 그러나 아쉽게도 `Cloneable` 은 의도한 목적을 제대로 이루지 못했다.
- 가장 큰 문제는 `clone` 메서드가 선언된 곳이 `Cloneable` 이 아닌 `Object` 이고 그마저도 protected 메서드라는 점이다. 따라서 `Cloneable` 을 구현하는 것만으로는 외부 객체에서 `clone` 메서드를 호출할 수 없다.
    - 리플렉션(아이템 65)을 사용하면 가능하지만, 100% 성공하는 것은 아니다. 해당 객체가 접근이 허용된 `clone` 메서드를 제공한다는 보장이 없기 때문이다.
- 하지만 이러한 문제점들에도 불구하고 `Cloneable` 방식은 널리 사용되고 있으므로 잘 알아두는 것이 좋다.

### (2) `Cloneable` 인터페이스가 하는 일

- `Cloneable` 인터페이스에는 메서드가 하나도 없다. 그러면 대체 이 인터페이스는 무슨 일을 하는가?
- `Cloneable` 인터페이스는 놀랍게도 Object의 protected 메서드인 `clone` 의 동작 방식을 결정한다.
    - `Cloneable` 을 구현한 클래스의 인스턴스에서 `clone` 을 호출하면 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 `clone` 을 호출하면 CloneNotSupportedException을 던진다.
    - 이는 인터페이스를 상당히 이례적으로 사용한 예시이니 따라해서는 안된다. 인터페이스를 구현한다는 것은 일반적으로 해당 클래스가 그 인터페이스에서 정의한 기능을 제공한다고 선언하는 행위이다. 그런데 `Cloneable` 의 경우에는 상위 클래스에 정의된 protected 메서드의 동작 방식을 변경한 것이다.
- 명세에서는 이야기하지 않지만 **실무에서 `Cloneable` 을 구현한 클래스는 `clone` 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄질 것으로 기대한다.** 이 기대를 만족시키기 위해서는 그 클래스와 모든 상위 클래스가 복잡하고, 강제할 수 없고, 허술하게 기술된 프로토콜을 지켜야 하는데, 그 결과 깨지기 쉽고, 위험하고, 모순적인 메커니즘이 탄생한다. 생성자를 호출하지 않고도 객체를 생성할 수 있게 되는 것이다.

### (3) `clone` 메서드의 허술한 일반 규약

- Object 명세에서 가져온 설명은 아래와 같다.
    - 이 객체의 복사본을 생성하여 반환한다. '복사'의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있다. 일반적인 의도는 다음과 같다. 어떤 객체 x에 대하여 다음 식은 참이다.
    - `x.clone() != x`
    - 또한 다음 식도 참이다.
    - `x.clone().getClass() == x.getClass()`
    - 하지만 이상의 요구를 반드시 만족해야 하는 것은 아니다.
    - 한편 다음 식도 일반적으로 참이지만, 역시 필수는 아니다.
    - `x.clone().equals(x)`
    - 관례상, 이 메서드가 반환하는 객체는 `super.clone` 을 호출하여 얻어야 한다. 이 클래스와 (Object를 제외한) 모든 상위 클래스가 이 관례를 따른다면 다음 식은 참이다.
    - `x.clone().getClass() == x.getClass()`
    - 관례상, 반환된 객체와 원본 객체는 독립적이어야 한다. 이를 만족하려면 `super.clone` 으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.

### (4) `clone` 메서드의 구현 방법 및 구현 시 주의사항

- **`clone` 메서드는 사실상 생성자와 같은 효과를 낸다. 즉, `clone` 은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.**
- **`Cloneable` 아키텍처는 '가변 객체를 참조하는 필드는 final로 선언하라'는 일반 용법과 충돌한다.** (단, 원본과 복제된 객체가 그 가변 객체를 공유해도 안전하다면 괜찮다)
- 생성자에서는 재정의될 수 있는 메서드를 호출하지 않아야 한다(아이템 19). 마찬가지로 `clone` 메서드 또한 재정의될 수 있는 메서드를 호출하지 않아야 한다. 만약 `clone` 메서드가 하위 클래스에서 재정의한 메서드를 호출한다면, 하위 클래스는 복제 과정에서 자신의 상태를 교정할 기회를 잃게 되어 원본과 복제본의 상태가 달라질 가능성이 크다. 따라서 `clone` 메서드가 호출하는 메서드는 final이거나 private이어야 한다. (private이라면 final이 아닌 public 메서드가 사용하는 도우미 메서드일 것이다)
- Object의 `clone` 메서드는 CloneNotSupportedException을 던진다고 선언했지만 재정의한 메서드는 그렇지 않다. **public인 `clone` 메서드에서는 throws 절을 없애야 한다.** Checked exception을 던지지 않아야 그 메서드를 사용하는 것이 편해지기 때문이다(아이템 71).
- 따라서 상속해서 사용하기 위한 클래스는 절대 `Cloneable` 을 구현해서는 안된다.
    - 제대로 작동하는 `clone` 메서드를 구현해서 protected로 두고 CloneNotSupportedException도 던질 수 있다고 선언하는 방식이 있다. Object의 방식을 모방한 것인데, `Cloneable` 구현 여부를 하위 클래스에서 선택하도록 해준다.
    - `clone` 을 동작하지 않도록 구현해놓고 하위 클래스에서 재정의하지 못하도록 하는 방식도 있다. 즉, `clone` 을 퇴화시켜놓는 방식이다.
- `Cloneable` 의 모든 문제점을 되짚어보면, 결국 새로운 인터페이스를 만들 때는 절대 `Cloneable` 을 확장해서는 안되며, 새로운 클래스도 이를 구현해서는 안된다.

### (5) 제일 좋은 방법 : 복사 생성자와 복사 팩토리 제공하기

- `Cloneable` 을 이미 구현한 클래스를 확장한다면 어쩔 수 없이 `clone` 을 잘 작동하도록 구현해야 한다. 하지만 그렇지 않은 상황에서는 **복사 생성자와 복사 팩토리라는 더 나은 객체 복사 방식**을 제공할 수 있다.
- 복사 생성자 : 단순히 자신과 같은 클래스의 인스턴스를 인수로 받는 생성자를 말한다.
    - `public Coffee(Coffee coffee) { ... };`
- 복사 팩토리 : 복사 생성자를 모방한 static 팩토리이다(아이템 1).
    - `public static Coffee newInstance(Coffee coffee) { ... };`

### (6) `Cloneable` 및 `clone` 과 비교하여 복사 생성자와 그 변형인 복사 팩토리의 장점

- 언어 모순적이고 위험천만한 객체 생성 메커니즘(생성자를 사용하지 않고 객체를 생성하는 방식)을 사용하지 않는다.
- 엉성하게 문서화된 규약에 의존하지 않는다.
- 정상적인 final 필드 용법과 충돌하지 않는다.
- 불필요한 checked exception을 던지지 않는다. 따라서 try-catch 블록으로 감쌀 필요가 없다.
- 형 변환이 필요하지 않다.
- 해당 클래스가 구현한 인터페이스 타입의 인스턴스를 인수로 받을 수 있다.
    - 예를 들어 관례상 모든 범용 컬렉션 구현체는 Collection이나 Map 타입을 받는 생성자를 제공한다.
- 인터페이스 기반 복사 생성자와 복사 팩토리의 더 정확한 이름은 변환 생성자(conversion constructor)와 변환 팩토리(conversion factory)이다. 이들을 이용하면 클라이언트는 원본 타입의 구현에 얽매이지 않고 복제본의 타입을 직접 선택할 수 있다.
    - 예를 들어, HashSet 객체 s를 TreeSet 타입으로 복제할 수 있다. `clone` 으로는 불가능한 이 기능을 변환 생성자로는 `new TreeSet<>(s)` 로 간단히 처리할 수 있다.

## ✅ 아이템 14. `Comparable` 을 구현할지 고려하라.

### (1) `Comparable` 인터페이스

- `Comparable` 인터페이스에는 유일한 메서드로 `compareTo` 가 있다.
- `compareTo` 메서드는 `equals` 메서드와 같이 **단순 동치성을 비교**할 수 있다.
- `compareTo` 메서드는 `equals` 메서드가 가지지 않은 두 가지 성격을 더 가지고 있는데, **순서를 비교**할 수 있으며 **제네릭**하다.
- 즉, `Comparable` 을 구현했다는 것은 그 클래스의 인스턴스들 사이에 자연적인 순서(natural order)가 존재한다는 의미이다.
- 따라서 `Comparable` 을 구현한 객체들의 배열은 `Arrays.sort(a)` 와 같이 손쉽게 정렬할 수 있다.

### (2) `compareTo` 메서드의 일반 규약

- `compareTo` 메서드의 일반 규약은 `equals` 의 규약과 비슷하다.
    - 이 객체와 주어진 객체의 순서를 비교한다. 이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환한다. 이 객체와 비교할 수 없는 타입의 객체가 주어지면 ClassCastException을 던진다.
    - 다음 설명에서 sgn(표현식) 표기는 수학에서 말하는 부호 함수(signum function)을 의미하며, 표현식의 값이 음수, 0, 양수일 때 각각 -1, 0, 1을 반환하도록 정의했다.
    - `Comparable` 을 구현한 클래스는 모든 `x` , `y` 에 대해 `sgn(x.compareTo(y)) == -sgn(y.compareTo(x))` 여야 한다. (따라서 `x.compareTo(y)` 는 `y.compareTo(x)` 가 예외를 던질 때에 한하여 예외를 던져야 한다)
    - `Comparable` 을 구현한 클래스는 추이성을 보장해야 한다. 즉, `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` 이면, `x.compareTo(z) > 0` 이어야 한다.
    - `Comparable` 을 구현한 클래스는 모든 `z` 에 대해 `x.compareTo(y) == 0` 이면, `sgn(x.compareTo(z)) == sgn(y.compareTo(z))` 이어야 한다.
    - 이번 권고가 필수는 아니지만 꼭 지키는 것이 좋다. `(x.compareTo(y) == 0) == (x.equals(y))` 여야 한다. `Comparable` 을 구현하고 이 권고를 지키지 않는 모든 클래스는 그 사실을 명시해야 한다. 다음과 같이 명시하면 적당할 것이다. "주의 : 이 클래스의 순서는 equals 메서드와 일관되지 않다."

### (3) `compareTo` 메서드의 구현

- 모든 객체에 대해 전역 동치관계를 부여하는 `equals` 메서드와 달리, `compareTo` 메서드는 타입이 다른 객체를 신경쓰지 않아도 된다. 즉, 타입이 다른 객체가 주어지면 간단히 ClassCastException을 던져도 되며, 대부분 그렇게 한다.
- 물론 이 규약에서는 다른 타입 사이의 비교도 허용하는데, 보통은 비교할 객체들이 구현한 공통 인터페이스를 매개로 이뤄진다.
- `hashCode` 규약을 지키지 못하면 해시를 사용하는 클래스와 어울리지 못하듯, `compareTo` 규약을 지키지 못하면 비교를 활용하는 클래스와 어울리지 못한다.
    - 해시를 사용하는 클래스의 예시 : HashSet, HashMap
    - 비교를 활용하는 클래스의 예시 : 정렬된 컬렉션인 TreeSet 및 TreeMap, 정렬 알고리즘을 활용하는 Collections 및 Arrays
- **`compareTo` 메서드에서 관계 연산자 `<` 와 `>` 를 사용하는 방식은 거추장스럽고 오류를 유발하므로 추천하지 않는다.** 기본 타입 필드를 비교할 때는 박싱된 기본 타입 클래스들에 새로 추가된 static 메서드인 `compare` 메서드를 이용하면 된다.
- 클래스에 핵심 필드가 여러 개라면 가장 핵심적인 필드부터 비교해야 한다. 비교 결과가 0이 아니라면 그 결과를 즉시 반환해야 한다. 가장 핵심이 되는 필드가 같다면, 같지 않은 필드를 찾을 때까지 그 다음으로 중요한 필드를 비교해나간다.
